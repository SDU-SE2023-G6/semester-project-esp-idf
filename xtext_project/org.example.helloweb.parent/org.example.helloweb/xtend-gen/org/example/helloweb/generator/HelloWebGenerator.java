/**
 * generated by Xtext 2.33.0
 */
package org.example.helloweb.generator;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class HelloWebGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field SensorConfig is undefined"
      + "\nThe method or field deviceTypes is undefined for the type EObject"
      + "\nThe method or field sensors is undefined for the type EObject"
      + "\nThe method or field sensors is undefined for the type EObject"
      + "\nThe method or field deviceTypes is undefined for the type EObject"
      + "\nThe method generateJsonLogs(EList<DeviceType>, EList<Sensor>, IFileSystemAccess2) from the type HelloWebGenerator refers to the missing type DeviceType"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThe method generateSensorCode(Sensor, IFileSystemAccess2) from the type HelloWebGenerator refers to the missing type Sensor"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThe method generateDeviceTypeCode(DeviceType, IFileSystemAccess2) from the type HelloWebGenerator refers to the missing type DeviceType"
      + "\nforEach cannot be resolved"
      + "\nforEach cannot be resolved");
  }

  public void generateSensorCode(final /* Sensor */Object sensor, final IFileSystemAccess2 fsa) {
    throw new Error("Unresolved compilation problems:"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nreader cannot be resolved"
      + "\nreader cannot be resolved"
      + "\nunits cannot be resolved"
      + "\nunits cannot be resolved"
      + "\nindexOf cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\nunits cannot be resolved"
      + "\nsize cannot be resolved"
      + "\npins cannot be resolved"
      + "\npins cannot be resolved"
      + "\nindexOf cannot be resolved"
      + "\nname cannot be resolved"
      + "\npins cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nout cannot be resolved"
      + "\nout cannot be resolved"
      + "\nindexOf cannot be resolved"
      + "\nname cannot be resolved"
      + "\nout cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nname cannot be resolved"
      + "\ntoUpperCase cannot be resolved"
      + "\nname cannot be resolved"
      + "\ntoUpperCase cannot be resolved"
      + "\nreader cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\ntoUpperCase cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved");
  }

  public void generateDeviceTypeCode(final /* DeviceType */Object deviceType, final IFileSystemAccess2 fsa) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field sensor is undefined for the type Object"
      + "\nThe method or field name is undefined for the type Object"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThe method generateCondition(DeviceType, SensorInstantiation, Condition) from the type HelloWebGenerator refers to the missing type DeviceType"
      + "\nname cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsensor cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsensor cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\npins cannot be resolved"
      + "\njoin cannot be resolved"
      + "\npins cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nsamplingRate cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nmap cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\njoin cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nbatchRatePolicy cannot be resolved"
      + "\nbatchSizePolicy cannot be resolved"
      + "\nheartBeatPolicy cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nsensor cannot be resolved"
      + "\nout cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nconstraints cannot be resolved"
      + "\ncondition cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nindexOf cannot be resolved"
      + "\nsamplingRate cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nindexOf cannot be resolved"
      + "\nsamplingRate cannot be resolved"
      + "\nname cannot be resolved"
      + "\ntoUpperCase cannot be resolved"
      + "\nname cannot be resolved"
      + "\ntoUpperCase cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nsensor cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\ntoUpperCase cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved");
  }

  public String generateCondition(final /* DeviceType */Object type, final /* SensorInstantiation */Object instantiation, final /* Condition */Object condition) {
    throw new Error("Unresolved compilation problems:"
      + "\nComparison cannot be resolved to a type."
      + "\nComparison cannot be resolved to a type."
      + "\nNestedLogicalCondition cannot be resolved to a type."
      + "\nNestedLogicalCondition cannot be resolved to a type."
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nThe method generateComparison(DeviceType, SensorInstantiation, Comparison) from the type HelloWebGenerator refers to the missing type DeviceType"
      + "\nThe method generateNestedLogicalCondition(DeviceType, SensorInstantiation, NestedLogicalCondition) from the type HelloWebGenerator refers to the missing type DeviceType");
  }

  public String generateComparison(final /* DeviceType */Object type, final /* SensorInstantiation */Object instantiation, final /* Comparison */Object comparison) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method generateComparisonValue(DeviceType, SensorInstantiation, ComparisonValue) from the type HelloWebGenerator refers to the missing type DeviceType"
      + "\nThe method generateComparisonValue(DeviceType, SensorInstantiation, ComparisonValue) from the type HelloWebGenerator refers to the missing type DeviceType"
      + "\nleft cannot be resolved"
      + "\nright cannot be resolved"
      + "\noperator cannot be resolved"
      + "\noperator cannot be resolved"
      + "\ntoString cannot be resolved");
  }

  public String generateComparisonValue(final /* DeviceType */Object type, final /* SensorInstantiation */Object instantiation, final /* ComparisonValue */Object value) {
    throw new Error("Unresolved compilation problems:"
      + "\nValueRef cannot be resolved to a type."
      + "\nDecimal cannot be resolved to a type."
      + "\nComparisonValue cannot be resolved to a type."
      + "\nUnreachable code: The case can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The case can never match. It is already handled by a previous condition."
      + "\nsensorInstantiation cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nsensorInstantiation cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nout cannot be resolved"
      + "\nleft cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nright cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\ntoString cannot be resolved"
      + "\ntoString cannot be resolved");
  }

  public String generateNestedLogicalCondition(final /* DeviceType */Object type, final /* SensorInstantiation */Object instantiation, final /* NestedLogicalCondition */Object condition) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method generateCondition(DeviceType, SensorInstantiation, Condition) from the type HelloWebGenerator refers to the missing type DeviceType"
      + "\nThe method generateCondition(DeviceType, SensorInstantiation, Condition) from the type HelloWebGenerator refers to the missing type DeviceType"
      + "\nleft cannot be resolved"
      + "\nright cannot be resolved"
      + "\noperator cannot be resolved"
      + "\noperator cannot be resolved"
      + "\ntoString cannot be resolved"
      + "\noperator cannot be resolved"
      + "\n== cannot be resolved");
  }

  public void generateSharedLibraryCode(final IFileSystemAccess2 fsa) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#ifndef SHARED_SNEM_LIBRARY_H");
    _builder.newLine();
    _builder.append("#define SHARED_SNEM_LIBRARY_H");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("#include <stdio.h>");
    _builder.newLine();
    _builder.append("#include <stdlib.h>");
    _builder.newLine();
    _builder.append("#include <string.h>");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("// Pre-identify types and constants");
    _builder.newLine();
    _builder.append("typedef struct Sensor Sensor;");
    _builder.newLine();
    _builder.append("typedef struct SensorInstantiation SensorInstantiation;");
    _builder.newLine();
    _builder.append("typedef struct DeviceType DeviceType;");
    _builder.newLine();
    _builder.append("typedef struct TimeDuration TimeDuration;");
    _builder.newLine();
    _builder.append("typedef enum TimeUnit TimeUnit;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#define MAX_CONSTRAINTS 10");
    _builder.newLine();
    _builder.append("#define MAX_UNITS 100");
    _builder.newLine();
    _builder.append("#define MAX_PINS 100");
    _builder.newLine();
    _builder.append("#define MAX_OUTPUTS 100");
    _builder.newLine();
    _builder.append("#define MAX_INSTANTIATIONS 100");
    _builder.newLine();
    _builder.newLine();
    _builder.append("enum TimeUnit {");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("SECOND,");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("MINUTE,");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("HOUR,");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("DAY");
    _builder.newLine();
    _builder.append("};");
    _builder.newLine();
    _builder.newLine();
    _builder.append("struct TimeDuration {");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("int value;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TimeUnit unit;");
    _builder.newLine();
    _builder.append("};");
    _builder.newLine();
    _builder.newLine();
    _builder.append("struct Sensor {");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("char name[100];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("char units[MAX_UNITS][100];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("int unitCount;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("char reader[150];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("double* (*readerFunction)(int*, int);");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("char pins[MAX_PINS][100];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("int pinCount;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("char out[MAX_OUTPUTS][100];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("int outCount;");
    _builder.newLine();
    _builder.append("};");
    _builder.newLine();
    _builder.newLine();
    _builder.append("struct SensorInstantiation {");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("Sensor* sensor;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("char name[100];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("int pins[MAX_PINS];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("int pinCount;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TimeDuration samplingRate;");
    _builder.newLine();
    _builder.append("};");
    _builder.newLine();
    _builder.newLine();
    _builder.append("struct DeviceType {");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("char name[100];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("SensorInstantiation* sensorInstantiations[MAX_INSTANTIATIONS];");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("int sensorCount;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TimeDuration batchRatePolicy;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("int batchSizePolicy;");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("TimeDuration heartBeatPolicy;");
    _builder.newLine();
    _builder.append("};");
    _builder.newLine();
    _builder.newLine();
    _builder.append("DeviceType *duplicateDeviceType(const DeviceType *original);");
    _builder.newLine();
    _builder.append("void freeDeviceType(DeviceType *deviceType);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("#endif // SHARED_SNEM_LIBRARY_H");
    _builder.newLine();
    final String headerFile = _builder.toString();
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("#include \"shared_snem_library.h\"");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("DeviceType* duplicateDeviceType(const DeviceType* original) {");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("// Allocate memory for the new DeviceType");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("DeviceType* duplicated = (DeviceType*)malloc(sizeof(DeviceType));");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("if (duplicated == NULL) {");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("fprintf(stderr, \"Memory allocation failed\\n\");");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("exit(EXIT_FAILURE);");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("// Copy the original DeviceType into the newly allocated memory");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("memcpy(duplicated, original, sizeof(DeviceType));");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("// Duplicate sensor instantiations");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("duplicated->sensorCount = original->sensorCount;");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("for (int i = 0; i < original->sensorCount; i++) {");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("// Allocate memory for each SensorInstantiation");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("SensorInstantiation* duplicatedInstantiation = (SensorInstantiation*)malloc(sizeof(SensorInstantiation));");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("if (duplicatedInstantiation == NULL) {");
    _builder_1.newLine();
    _builder_1.append("            ");
    _builder_1.append("fprintf(stderr, \"Memory allocation failed\\n\");");
    _builder_1.newLine();
    _builder_1.append("            ");
    _builder_1.append("exit(EXIT_FAILURE);");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("// Copy the original SensorInstantiation into the duplicated one");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("memcpy(duplicatedInstantiation, original->sensorInstantiations[i], sizeof(SensorInstantiation));");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("// Update the pointer in the duplicated DeviceType");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("duplicated->sensorInstantiations[i] = duplicatedInstantiation;");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("return duplicated;");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.newLine();
    _builder_1.append("void freeDeviceType(DeviceType* deviceType) {");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("if (deviceType == NULL) {");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("return;");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("// Free each SensorInstantiation");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("for (int i = 0; i < deviceType->sensorCount; i++) {");
    _builder_1.newLine();
    _builder_1.append("        ");
    _builder_1.append("free(deviceType->sensorInstantiations[i]);");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("}");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("// Free the DeviceType itself");
    _builder_1.newLine();
    _builder_1.append("    ");
    _builder_1.append("free(deviceType);");
    _builder_1.newLine();
    _builder_1.append("}");
    _builder_1.newLine();
    final String sourceFile = _builder_1.toString();
    fsa.generateFile("shared_snem_library.h", headerFile);
    fsa.generateFile("shared_snem_library.c", sourceFile);
  }

  public String extractXTextTimeUnitCount(final String timeDuration) {
    String _xblockexpression = null;
    {
      if (((timeDuration == null) || timeDuration.isEmpty())) {
        return "1";
      }
      _xblockexpression = timeDuration.replaceAll("\\D", "");
    }
    return _xblockexpression;
  }

  public String extractXTextTimeUnit(final String timeDuration) {
    if (((timeDuration == null) || timeDuration.isEmpty())) {
      return "SECOND";
    }
    timeDuration.replaceAll("\\d", "");
    if (timeDuration != null) {
      switch (timeDuration) {
        case "s":
          return "SECOND";
        case "m":
          return "MINUTE";
        case "h":
          return "HOUR";
        case "d":
          return "DAY";
        default:
          return "SECOND";
      }
    } else {
      return "SECOND";
    }
  }

  public String mapXTextTimeUnitToC(final String timeDuration) {
    if (((timeDuration == null) || timeDuration.isEmpty())) {
      return "{1, SECOND}";
    }
    final String count = timeDuration.replaceAll("\\D", "");
    final String unit = timeDuration.replaceAll("\\d", "");
    if (unit != null) {
      switch (unit) {
        case "s":
          return (("{" + count) + ", SECOND}");
        case "m":
          return (("{" + count) + ", MINUTE}");
        case "h":
          return (("{" + count) + ", HOUR}");
        case "d":
          return (("{" + count) + ", DAY}");
        default:
          return "{1, SECOND}";
      }
    } else {
      return "{1, SECOND}";
    }
  }

  public void generateJsonLogs(final /* EList<DeviceType> */Object deviceTypes, final /* EList<Sensor> */Object sensors, final IFileSystemAccess2 fsa) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field value is undefined for the type Object"
      + "\nThe method or field name is undefined for the type Object"
      + "\nThe method or field name is undefined for the type Object"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nname cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsensor cannot be resolved"
      + "\nname cannot be resolved"
      + "\npins cannot be resolved"
      + "\njoin cannot be resolved"
      + "\nsamplingRate cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nsensorInstantiations cannot be resolved"
      + "\nlast cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nname cannot be resolved"
      + "\nreader cannot be resolved"
      + "\nunits cannot be resolved"
      + "\nmap cannot be resolved"
      + "\njoin cannot be resolved"
      + "\npins cannot be resolved"
      + "\nmap cannot be resolved"
      + "\njoin cannot be resolved"
      + "\nout cannot be resolved"
      + "\nmap cannot be resolved"
      + "\njoin cannot be resolved"
      + "\n!= cannot be resolved");
  }
}
